import { observable } from "mobx"
import * as _ from "lodash"

import { Gamepad, IGamepadEvent } from "./Gamepad"

type Point = {
    x: number;
    y: number;
}

export interface Focusable {
    id: string;
    boundingRect: DOMRect;
}

class FocusStore {
    @observable private _focusables: Map<string, any> = new Map()
    @observable private _focused: string = null
    @observable private _previouslyFocused: string = null

    gamepad = new Gamepad(true);

    constructor() {
        this.gamepad.on("gamepadevent", this.handleGamepadInput.bind(this))
        window.addEventListener("keydown", this.handleKeyboardInput.bind(this))
    }

    // PRIVATE

    private handleGamepadInput(e: IGamepadEvent) {
        this.handleKeyboardInput(e)

        if (e.keyCode > 11 && e.keyCode < 16 && this._focusables.size) {
            this.navigate(e.keyCode)
        }
    }

    private handleKeyboardInput(e: KeyboardEvent | IGamepadEvent) {
        if (e.keyCode > 36 && e.keyCode < 41 && this._focusables.size) {
            this.navigate(e.keyCode)
        }
    }

    private navigate(keyCode: number) {
        if (!this.focused) return

        const focusedPosition = this.calculatePosition(this.focusedWithProps)

        const relevantFocusables = this.focusables.filter(focusable => {
            // if (!focusable.visible || focusable.opacity === 0) return false

            let focusablePosition = this.calculatePosition(focusable)

            switch (keyCode) {
                case 13:
                case 37:
                    return focusablePosition.x < focusedPosition.x
                case 11:
                case 38:
                    return focusablePosition.y < focusedPosition.y
                case 14:
                case 39:
                    return focusablePosition.x > focusedPosition.x
                case 12:
                case 40:
                    return focusablePosition.y > focusedPosition.y
            }
        })

        const sortedFocusables = _.sortBy(relevantFocusables, focusable => {
            let angleOffset

            switch (keyCode) {
                case 13:
                case 37:
                    angleOffset = 90
                    break
                case 11:
                case 38:
                    angleOffset = 0
                    break
                case 14:
                case 39:
                    angleOffset = 90
                    break
                case 12:
                case 40:
                    angleOffset = 180
                    break
            }

            let focusablePosition = this.calculatePosition(focusable)

            const distance = this.calculateDistance(
                focusedPosition,
                focusablePosition
            )
            const angle = this.calculateAngle(
                focusedPosition,
                focusablePosition
            )
            const score = this.calculateScore(distance, angleOffset, angle)

            return score
        })

        if (sortedFocusables.length) {
            this.focused = sortedFocusables[0].id
        }
    }

    private calculatePosition(focusable: Focusable): Point {
        const center = {
            x: focusable.boundingRect.x + focusable.boundingRect.width / 2,
            y: focusable.boundingRect.y + focusable.boundingRect.height / 2,
        }

        return center
    }

    private calculateDistance(pointA: Point, pointB: Point) {
        const xDelta = Math.abs(pointA.x - pointB.x)
        const yDelta = Math.abs(pointA.y - pointB.y)

        return Math.sqrt(Math.abs(xDelta * xDelta + yDelta * yDelta))
    }

    private calculateAngle(pointA: Point, pointB: Point) {
        const xDelta = pointA.x - pointB.x
        const yDelta = pointA.y - pointB.y
        const atan2 = Math.atan2(xDelta, yDelta)

        return Math.abs((atan2 * 180) / Math.PI)
    }

    private calculateScore(
        distance: number,
        angleOffset: number,
        angle: number
    ) {
        return distance + Math.abs(angleOffset - angle)
    }

    public addFocusable(focusable: Focusable) {
        this._focusables.set(focusable.id, focusable)
        if (!this._focused) {
            this._focused = focusable.id
        }
    }

    public removeFocusable(id: string) {
        this._focusables.delete(id)
        if (this._focused === id) {
            this._focused = null

            if (this._focusables.size) {
                this.focused = [...this._focusables.keys()][0]
            }
        }
    }

    public get focusables() {
        return [...this._focusables.values()]
    }

    public get focused() {
        return this._focused
    }

    public set focused(id) {
        this._previouslyFocused = this._focused
        this._focused = id
    }

    public get focusedWithProps() {
        return this._focusables.get(this._focused)
    }

    public get previouslyFocused() {
        return this._previouslyFocused
    }
}

export default new FocusStore()
